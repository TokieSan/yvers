--- b/src/app.rs
+++ a/src/app.rs
@@ -11,6 +11,7 @@
 pub struct Widgets<'a, 'b> {
 	pub battery: Option<BatteryWidget<'a>>,
 	pub cpu: Option<CpuWidget<'a>>,
+	pub mem: Option<MemWidget<'a>>,
 	pub net: Option<NetWidget<'a, 'b>>,
 	pub proc: Option<ProcWidget<'a>>,
 }
@@ -34,6 +35,12 @@
         None
     };  
 
+    let mem = if args.mem || args.everything {
+        Some(MemWidget::new(colorscheme, args.interval)) 
+    } else {
+        None
+    };
+
     let net = if args.net || args.everything {
         Some(NetWidget::new(colorscheme, &args.interface))
     } else {
@@ -58,6 +65,7 @@
 		widgets: Widgets {
 			battery,
 			cpu,
+			mem,
 			net,
 			proc,
 		},
--- b/src/args.rs
+++ a/src/args.rs
@@ -16,6 +16,9 @@
 	#[structopt(short = "C", long = "cpu")]
 	pub cpu: bool,  
 
+	#[structopt(short = "M", long = "mem")]
+	pub mem: bool,
+
 	#[structopt(short = "N", long = "net")]
 	pub net: bool,   
 
--- b/src/draw.rs
+++ a/src/draw.rs
@@ -19,6 +19,9 @@
     if widgets.cpu.is_some() {
         count += 1;
     }
+    if widgets.mem.is_some() {
+        count += 1;
+    }
     if widgets.net.is_some() {
         count += 1;
     }
@@ -62,6 +65,11 @@
         row_idx += 1;
     }
 
+    if let Some(mem) = widgets.mem.as_ref() {
+        frame.render_widget(mem, chunks[row_idx]);
+        row_idx += 1;
+    }
+
     if let Some(net) = widgets.net.as_ref() {
         frame.render_widget(net, chunks[row_idx]);
         row_idx += 1;
--- b/src/update.rs
+++ a/src/update.rs
@@ -19,6 +19,10 @@
         widgets_to_update.push(cpu);
     }
 
+    if let Some(mem) = widgets.mem.as_mut() {
+        widgets_to_update.push(mem);
+    }   
+
     if let Some(proc) = widgets.proc.as_mut() {
         widgets_to_update.push(proc);
     }
--- /dev/null
+++ a/src/widgets/mem.rs
@@ -0,0 +1,159 @@
+use num_rational::Ratio;
+use psutil::memory;
+use size::Size;
+use tui::buffer::Buffer;
+use tui::layout::Rect;
+use tui::symbols::Marker;
+use tui::widgets::{Axis, Chart, Dataset, GraphType, Widget};
+
+use crate::colorscheme::Colorscheme;
+use crate::update::UpdatableWidget;
+use crate::widgets::block;
+
+const HORIZONTAL_SCALE_DELTA: u64 = 25;
+
+#[derive(Default)]
+struct MemData {
+	total: u64,
+	used: u64,
+	percents: Vec<(f64, f64)>,
+}
+
+pub struct MemWidget<'a> {
+	title: String,
+	update_interval: Ratio<u64>,
+	colorscheme: &'a Colorscheme,
+
+	horizontal_scale: u64,
+
+	update_count: u64,
+
+	main: MemData,
+	swap: Option<MemData>,
+}
+
+impl MemWidget<'_> {
+	pub fn new(colorscheme: &Colorscheme, update_interval: Ratio<u64>) -> MemWidget {
+		let update_count = 0;
+
+		let mut main = MemData::default();
+		main.percents.push((update_count as f64, 0.0));
+
+		MemWidget {
+			title: " Memory Usage ".to_string(),
+			update_interval,
+			colorscheme,
+
+			horizontal_scale: 100,
+
+			update_count,
+
+			main,
+			swap: None,
+		}
+	}
+
+	pub fn scale_in(&mut self) {
+		if self.horizontal_scale > HORIZONTAL_SCALE_DELTA {
+			self.horizontal_scale -= HORIZONTAL_SCALE_DELTA;
+		}
+	}
+
+	pub fn scale_out(&mut self) {
+		self.horizontal_scale += HORIZONTAL_SCALE_DELTA;
+	}
+}
+
+impl UpdatableWidget for MemWidget<'_> {
+	fn update(&mut self) {
+		self.update_count += 1;
+
+		let main = memory::virtual_memory().unwrap();
+		let swap = memory::swap_memory().unwrap();
+
+		self.main.total = main.total();
+		self.main.used = main.used();
+		self.main
+			.percents
+			.push((self.update_count as f64, main.percent().into()));
+
+		if swap.total() == 0 {
+			self.swap = None;
+		} else {
+			if self.swap.is_none() {
+				self.swap = Some(MemData::default());
+				self.swap
+					.as_mut()
+					.unwrap()
+					.percents
+					.push((self.update_count as f64 - 1.0, 0.0));
+			}
+			self.swap.as_mut().unwrap().total = swap.total();
+			self.swap.as_mut().unwrap().used = swap.used();
+			self.swap
+				.as_mut()
+				.unwrap()
+				.percents
+				.push((self.update_count as f64, swap.percent().into()));
+		}
+	}
+
+	fn get_update_interval(&self) -> Ratio<u64> {
+		self.update_interval
+	}
+}
+
+impl Widget for &MemWidget<'_> {
+	fn render(self, area: Rect, buf: &mut Buffer) {
+		let mut datasets = vec![Dataset::default()
+			.marker(Marker::Braille)
+			.graph_type(GraphType::Line)
+			.style(self.colorscheme.mem_main)
+			.data(&self.main.percents)];
+		if let Some(swap) = &self.swap {
+			datasets.push(
+				Dataset::default()
+					.marker(Marker::Braille)
+					.graph_type(GraphType::Line)
+					.style(self.colorscheme.mem_swap)
+					.data(&swap.percents),
+			)
+		}
+
+		Chart::<String, String>::default()
+			.block(block::new(self.colorscheme, &self.title))
+			.x_axis(Axis::default().bounds([
+				self.update_count as f64 - self.horizontal_scale as f64,
+				self.update_count as f64 + 1.0,
+			]))
+			.y_axis(Axis::default().bounds([0.0, 100.0]))
+			.datasets(&datasets)
+			.render(area, buf);
+
+		buf.set_string(
+			area.x + 3,
+			area.y + 2,
+			format!(
+				"Main {:3.0}% {}/{}",
+				self.main.percents.last().unwrap().1,
+				Size::Bytes(self.main.used),
+				Size::Bytes(self.main.total),
+			),
+			self.colorscheme.mem_main,
+		);
+
+		if let Some(swap) = &self.swap {
+			buf.set_string(
+				area.x + 3,
+				area.y + 3,
+				format!(
+					"Swap {:3.0}% {}/{}",
+					swap.percents.last().unwrap().1,
+					Size::Bytes(swap.used),
+					Size::Bytes(swap.total),
+				),
+				self.colorscheme.mem_swap,
+			);
+		}
+	}
+}
--- b/src/widgets/mod.rs
+++ a/src/widgets/mod.rs
@@ -2,6 +2,7 @@
 mod block;
 mod cpu;
 mod help_menu;
+mod mem;
 mod net;
 mod proc;
 mod statusbar;
@@ -9,6 +10,7 @@
 pub use self::battery::BatteryWidget;
 pub use self::cpu::CpuWidget;
 pub use self::help_menu::HelpMenu;
+pub use self::mem::MemWidget;
 pub use self::net::NetWidget;
 pub use self::proc::ProcWidget;
 pub use self::statusbar::Statusbar;
